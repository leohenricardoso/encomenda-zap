generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ─── Store ────────────────────────────────────────────────────────────────────
// Represents a business (tenant) using the platform.
// Each Store will own its products, orders and customers.

model Store {
  id        String   @id @default(uuid())
  name      String
  /// URL-safe identifier used in the public catalog: /catalog/:slug
  slug      String?  @unique
  whatsapp  String
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  admin        Admin?
  products     Product[]
  customers    Customer[]
  orders       Order[]
  schedules    StoreSchedule[]
  pickupSlots  StorePickupSlot[]
  cepRanges    StoreCepRange[]
  orderCounter StoreOrderCounter?
  messageConfig StoreMessageConfig?

  @@index([slug])
  @@map("stores")
}


// ─── Admin ────────────────────────────────────────────────────────────────────
// Store owner — the authenticated user of the platform.
// One Admin belongs to exactly one Store (1:1 for MVP).

model Admin {
  id           String   @id @default(uuid())
  email        String   @unique
  passwordHash String
  storeId      String   @unique
  createdAt    DateTime @default(now())

  store Store @relation(fields: [storeId], references: [id])

  @@map("admins")
}

// ─── PricingType ──────────────────────────────────────────────────────────────
// How a variant (or simple product) is priced.

enum PricingType {
  UNIT    // sold by piece
  WEIGHT  // sold by weight (e.g. kg, g)
}

// ─── Product ──────────────────────────────────────────────────────────────────
// Conceptual item offered by a Store (e.g. "Bolo de Chocolate").
//
// price:       nullable — null means pricing is delegated to variants.
//              Kept for backward-compat with existing simple products.
// minQuantity: minimum order quantity enforced at checkout.

model Product {
  id          String   @id @default(uuid())
  storeId     String
  name        String
  description String?
  /// Base price for simple products. NULL when using variants.
  price       Decimal? @db.Decimal(10, 2)
  /// Minimum units a customer must order (default 1)
  minQuantity Int      @default(1)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  store      Store            @relation(fields: [storeId], references: [id])
  variants   ProductVariant[]
  orderItems OrderItem[]

  @@index([storeId])
  @@map("products")
}

// ─── ProductVariant ───────────────────────────────────────────────────────────
// A purchasable option of a Product (e.g. "500g – R$ 29,90").
//
// storeId is denormalised from the parent Product so variants can be queried
// with a single WHERE storeId = ? without a join — enforces multi-tenancy.

model ProductVariant {
  id          String      @id @default(uuid())
  productId   String
  /// Denormalised from Product — enables tenant-scoped queries on variants alone.
  storeId     String
  /// Human-readable option label ("P", "M", "G" / "Chocolate" / "500g").
  label       String
  price       Decimal     @db.Decimal(10, 2)
  pricingType PricingType @default(UNIT)
  isActive    Boolean     @default(true)
  /// Display order within the product's variant list (lower = first).
  sortOrder   Int         @default(0)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  product    Product     @relation(fields: [productId], references: [id], onDelete: Cascade)
  orderItems OrderItem[]

  @@index([productId])
  @@index([storeId])
  @@map("product_variants")
}

// ─── Customer ─────────────────────────────────────────────────────────────────
// A customer who has placed (or is about to place) an order at a Store.
//
// whatsapp: stored normalised — digits only with country code (e.g. "5511999998888").
//           The @@unique([whatsapp, storeId]) constraint ensures that the same
//           phone number is treated as one customer per store, enabling dedup
//           when incoming WhatsApp messages arrive.
//
// Future: add an `orders Order[]` relation once the Order model is introduced.

model Customer {
  id        String   @id @default(uuid())
  storeId   String
  name      String
  /// Normalised digits-only string with country code. Example: "5511999998888".
  whatsapp  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  store  Store   @relation(fields: [storeId], references: [id])
  orders Order[]

  /// One customer per WhatsApp number per store.
  @@unique([whatsapp, storeId])
  @@index([storeId])
  @@map("customers")
}

// ─── OrderStatus ──────────────────────────────────────────────────────────────
// Lifecycle states of an Order — mirrors the domain enum in Order.ts.
// Adding a new status requires:
//   1. New enum value here.
//   2. New entry in ALLOWED_TRANSITIONS (Order.ts).
//   3. A schema migration.

enum OrderStatus {
  PENDING   // Created, awaiting store review.
  APPROVED  // Store accepted the order.
  REJECTED  // Store declined the order.
}

// ─── FulfillmentType ──────────────────────────────────────────────────────────
// How the customer wants to receive the order.

enum FulfillmentType {
  PICKUP    // Customer picks up at the store.
  DELIVERY  // Order is delivered to the customer's address.
}

// ─── Order ────────────────────────────────────────────────────────────────────
// A purchase request placed by a Customer at a Store.
//
// shippingAddress: nullable — null means pickup at the store.
// deliveryDate:    when the order should be ready / delivered.
// status:          starts as PENDING; transitions controlled by domain rules.
//
// Future relations to add as features grow:
//   items         OrderItem[]      — line items (product/variant + qty + price)
//   statusHistory OrderStatusLog[] — full audit trail of transitions
//   payment       Payment?         — payment intent / confirmation

model Order {
  id              String          @id @default(uuid())
  storeId         String
  customerId      String
  deliveryDate    DateTime
  /// PICKUP = customer collects at store; DELIVERY = home delivery.
  fulfillmentType FulfillmentType @default(PICKUP)
  /// Human-readable pickup time window, e.g. "09:00 – 12:00". PICKUP only.
  pickupTime      String?
  /// FK to StorePickupSlot — stored for traceability. PICKUP only.
  pickupSlotId    String?
  /// 8-digit CEP (no hyphen). DELIVERY only.
  deliveryCep     String?
  /// Street name. DELIVERY only.
  deliveryStreet  String?
  /// House / apartment number. DELIVERY only.
  deliveryNumber  String?
  /// Neighbourhood / bairro. DELIVERY only.
  deliveryNeighborhood String?
  /// City. DELIVERY only.
  deliveryCity    String?
  /// Legacy free-text address (kept for backward compat). Populated from structured fields.
  shippingAddress String?
  /// Optional free-text note left by the customer when placing the order.
  notes           String?
  /// Per-store sequential number shown to customers and the store owner (e.g. #42).
  /// Generated atomically on creation; NULL only for orders migrated from before this field.
  orderNumber     Int?
  /// Current lifecycle state. Always starts as PENDING.
  status          OrderStatus     @default(PENDING)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  store    Store       @relation(fields: [storeId], references: [id])
  customer Customer    @relation(fields: [customerId], references: [id])
  items    OrderItem[]

  /// Query orders by store, filtered by status (dashboard, KPIs).
  @@index([storeId, status])
  /// Query all orders for a customer within a store (order history).
  @@index([customerId, storeId])
  /// Query by delivery date for scheduling / dispatch views.
  @@index([storeId, deliveryDate])
  @@map("orders")
}

// ─── OrderItem ──────────────────────────────────────────────────────────────────
// An immutable snapshot of a single product (or variant) within an Order.
//
// Price-freezing invariant: unitPrice is written once at order creation
// and NEVER updated.  Historical orders always reflect the price paid.
//
// productName / variantLabel are snapshot strings — stored so that receipts
// and history views remain accurate even after catalogue edits.
//
// discountAmount: per-unit discount at order time, 0 by default.
//   Future coupon / loyalty discount features write to this field.
//   lineTotal = (unitPrice - discountAmount) * quantity
//
// Future columns to add without breaking changes:
//   notes    String?   — per-item kitchen instructions
//   couponId String?   — FK to a future Coupon model
//   tax      Decimal?  — tax per unit for fiscal notes

model OrderItem {
  id             String   @id @default(uuid())
  orderId        String
  productId      String
  variantId      String?
  /// Snapshot of product name at order creation time.
  productName    String
  /// Snapshot of variant label at order creation time. Null for simple products.
  variantLabel   String?
  /// Number of units ordered. Must be >= the product's minQuantity.
  quantity       Int
  /// Unit price frozen at order creation. Never recalculated.
  unitPrice      Decimal  @db.Decimal(10, 2)
  /// Per-unit discount applied at order time. Defaults to 0.
  discountAmount Decimal  @default(0) @db.Decimal(10, 2)
  createdAt      DateTime @default(now())

  order   Order          @relation(fields: [orderId],   references: [id], onDelete: Cascade)
  product Product        @relation(fields: [productId], references: [id])
  variant ProductVariant? @relation(fields: [variantId], references: [id])

  /// Fetch all items for a given order efficiently.
  @@index([orderId])
  @@map("order_items")
}

// ─── StoreOrderCounter ────────────────────────────────────────────────────────
// Per-store monotonically-increasing counter for human-friendly order numbers.
//
// Design:
// ─ One row per store; storeId is both the PK and the FK.
// ─ lastNumber starts at 0; it is incremented atomically inside a transaction
//   before every Order.create().  The newly-incremented value is written to
//   orders.orderNumber, giving each store its own #1, #2, #3 … sequence.
// ─ Because the upsert + order creation happen in a single serialisable
//   transaction, two concurrent inserts for the same store will never receive
//   the same orderNumber.

model StoreOrderCounter {
  storeId    String @id
  lastNumber Int    @default(0)

  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@map("store_order_counters")
}

// ─── StoreMessageConfig ───────────────────────────────────────────────────────
// Per-store customisable WhatsApp message templates.
//
// Design:
// ─ Optional 1:1 with Store.  When no row exists the application falls back
//   to built-in default messages.
// ─ Templates support three placeholders: {cliente}, {pedido}, {data}.
//   The application layer resolves them; this table stores raw template text.
// ─ Both fields are nullable — the admin may configure one without the other.
// ─ Prepared for future channels (email, SMS) by keeping the model separate
//   from the order/store tables.

model StoreMessageConfig {
  storeId          String  @id
  /// Message sent to a customer when their order is approved.
  /// Supports: {cliente}, {pedido}, {data}. Max 500 chars.
  approvalMessage  String? @db.VarChar(500)
  /// Message sent to a customer when their order is rejected.
  /// Supports: {cliente}, {pedido}, {data}. Max 500 chars.
  rejectionMessage String? @db.VarChar(500)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@map("store_message_configs")
}

// ─── StoreSchedule ────────────────────────────────────────────────────────────
// Per-store override table for day availability.
//
// Design: this table records ONLY explicit overrides from the default rule.
// Default rule (applied in the application layer, not the DB):
//   Monday–Friday  → isOpen = true
//   Saturday–Sunday → isOpen = false
//
// When a date is absent from this table the application falls back to the
// default.  Rows are inserted (or upserted) only when an admin explicitly
// opens or closes a specific date.
//
// date: stored as a YYYY-MM-DD string to avoid timezone ambiguity.
//       Queries always compare strings, never cast to timestamp.
//
// @@unique([storeId, date]) prevents duplicate overrides and is the upsert key.

model StoreSchedule {
  id        String   @id @default(uuid())
  storeId   String
  /// Calendar date in YYYY-MM-DD format (e.g. "2026-03-15").
  date      String
  isOpen    Boolean
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@unique([storeId, date])
  @@index([storeId])
  @@map("store_schedules")
}

// ─── StorePickupSlot ──────────────────────────────────────────────────────────
// Recurring weekly time-windows during which a store accepts pickup orders.
//
// Design notes:
// ─ A store may define multiple slots per day (e.g. 09:00–12:00 and 14:00–18:00).
// ─ startTime / endTime are stored as "HH:mm" strings.  Lexicographic comparison
//   is valid because the format is fixed-width (zero-padded).
// ─ Overlap validation is enforced in the application layer (CreatePickupSlotUseCase)
//   so the DB stays schema-only.  The unique index on (storeId, dayOfWeek) would
//   be too restrictive; the app layer checks against active slots only.
// ─ isActive: false means the slot is soft-deleted (kept for audit / recovery).
// ─ dayOfWeek follows JS convention: 0 = Sunday … 6 = Saturday.

model StorePickupSlot {
  id         String   @id @default(uuid())
  storeId    String
  /// 0 = Sunday, 1 = Monday … 6 = Saturday (JS Date.getDay() convention).
  dayOfWeek  Int
  /// Opening time in HH:mm format (e.g. "09:00").
  startTime  String
  /// Closing time in HH:mm format (e.g. "12:00"). Must be > startTime.
  endTime    String
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@index([storeId, dayOfWeek])
  @@map("store_pickup_slots")
}

// ─── StoreCepRange ─────────────────────────────────────────────────────────────────
// Delivery constraint — a store may define multiple CEP (postal code) ranges.
// A customer CEP is accepted if it falls within ANY configured range.
//
// Design notes:
// ─ Multiple rows per store (1:N); storeId is indexed, not unique.
// ─ cepStart / cepEnd are 8-digit numeric strings (no hyphen, zero-padded).
//   Lexicographic comparison is valid because strings are fixed-width.
// ─ When no rows exist for a store, delivery is unrestricted.

model StoreCepRange {
  id        String   @id @default(uuid())
  storeId   String
  /// First CEP of the delivery range. 8 digits, no hyphen (e.g. "01310000").
  cepStart  String
  /// Last CEP of the delivery range. 8 digits, no hyphen (e.g. "01319999").
  cepEnd    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@index([storeId])
  @@map("store_cep_ranges")
}